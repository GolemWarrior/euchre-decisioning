# -*- coding: utf-8 -*-
"""Euchre.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zfa3xxjqwCZO7WSmofLYij4S2FaH8bKP
"""

from enum import IntEnum
from itertools import product
import numpy as np
import random
import time

# Define IntEnums for each card, each suit, and each rank used in Euchre
SUITS = ["SPADES", "CLUBS", "HEARTS", "DIAMONDS"]  # Order is important for binary operations
RANKS = ["9", "10", "JACK", "QUEEN", "KING"]  # Order is important for int operations
card_enum_strings = [(suit + "_" + rank, index) for index, (suit, rank) in enumerate(product(SUITS, RANKS))]
DECK_SIZE = len(card_enum_strings)
ECard = IntEnum('ECard', card_enum_strings)
ESuit = IntEnum('ESuit', [(suit, index) for index, suit in enumerate(SUITS)])
ERank = IntEnum('ERank', [(rank, index) for index, rank in enumerate(RANKS)])

def get_ecard_esuit(ecard):
    assert ecard is not None, "ecard is None!"
    return ESuit(int((ecard) / len(RANKS)))

def get_ecard_erank(ecard):
    assert ecard is not None, "ecard is None!"
    return ERank(ecard % len(RANKS))

def get_same_color_esuit(esuit):
    # Gets the other suit with the same color.
    # (Assumes 4 suits and same colors are next to each other)
    return ESuit(esuit ^ 1)

JACK = ERank["JACK"]
def get_ecard_score(ecard, trump_esuit, led_esuit):
    card_esuit = get_ecard_esuit(ecard)
    card_erank = get_ecard_erank(ecard)
    is_trump_suit = card_esuit == trump_esuit
    is_same_color_suit = card_esuit == get_same_color_esuit(trump_esuit)

    max_led_score = len(RANKS)
    max_trump_score = max_led_score + len(RANKS)

    # Score bowers
    if card_erank == JACK:
        if is_trump_suit:
            return max_trump_score + 2
        elif is_same_color_suit:
            return max_trump_score + 1

    # Score non-bower trump suit cards
    if is_trump_suit:
        return max_led_score + card_erank

    # Score non-bower, non-trump, led suit cards
    elif card_esuit == led_esuit:
        return int(card_erank) + 1

    # Non-bower, non-trump, and non-led can't win
    return 0


class Deck:
    def __init__(self):
        self.cards = np.ones((DECK_SIZE, 1))
        self.card_count = DECK_SIZE

    def draw_ecards(self, draw_count=1):
        random_cards = np.random.choice(np.nonzero(self.cards)[0], size=draw_count, replace=False)
        self.cards[random_cards, 0] = 0
        self.card_count -= draw_count
        return random_cards


PLAYERS = ["Player0_Team0", "Player1_Team1", "Player2_Team0", "Player3_Team1"]  # Order is important
EPlayer = IntEnum('EPlayers', [(player, index) for index, player in enumerate(PLAYERS)])

def get_teammate(eplayer):
    # Gets the other player on the same team.
    # (Assumes 4 players and same team players are next to each other)
    return EPlayer((eplayer + 2) % 4)

def are_eplayers_same_team(eplayer1, eplayer2):
    return get_teammate(eplayer1) == eplayer2

def eplayer_to_team_index(eplayer):
    return eplayer % 2

def get_other_team_index(team_index):
    assert team_index == 0 or team_index == 1, "Team index is either 0 or 1!"
    return 1 - team_index  # {0: 1, 1: 0}

def get_clockwise_player(eplayer):
    return EPlayer((eplayer + 1) % 4)


ROUND_STATES = ["FIRST_BIDDING", "DEALER_DISCARD", "DECIDING_GOING_ALONE", "SECOND_BIDDING", "CHOOSING_ESUIT", "PLAYING"]
RoundEState = IntEnum("RoundEState", [(round_state, index) for index, round_state in enumerate(ROUND_STATES)])
FIRST_BIDDING_STATE =        RoundEState["FIRST_BIDDING"]
DEALER_DISCARD_STATE =       RoundEState["DEALER_DISCARD"]
DECIDING_GOING_ALONE_STATE = RoundEState["DECIDING_GOING_ALONE"]
SECOND_BIDDING_STATE =       RoundEState["SECOND_BIDDING"]
CHOOSING_ESUIT_STATE =       RoundEState["CHOOSING_ESUIT"]
PLAYING_STATE =              RoundEState["PLAYING"]


ACTIONS = ["PLAY_CARD_1", "PLAY_CARD_2", "PLAY_CARD_3", "PLAY_CARD_4",
           "ORDER_UP", "PASS",
           "GO_ALONE", "DONT_GO_ALONE",
           "CHOOSE_SPADES", "CHOOSE_CLUBS", "CHOOSE_HEARTS", "CHOOSE_DIAMONDS"
           ]
EAction = IntEnum("EAction", [(action_name, index) for index, action_name in enumerate(ACTIONS)])
PLAY_CARD_1 =     EAction["PLAY_CARD_1"]
PLAY_CARD_2 =     EAction["PLAY_CARD_2"]
PLAY_CARD_3 =     EAction["PLAY_CARD_3"]
PLAY_CARD_4 =     EAction["PLAY_CARD_4"]
ORDER_UP =        EAction["ORDER_UP"]
PASS =            EAction["PASS"]
GO_ALONE =        EAction["GO_ALONE"]
DONT_GO_ALONE =   EAction["DONT_GO_ALONE"]
CHOOSE_SPADES =   EAction["CHOOSE_SPADES"]
CHOOSE_CLUBS =    EAction["CHOOSE_CLUBS"]
CHOOSE_HEARTS =   EAction["CHOOSE_HEARTS"]
CHOOSE_DIAMONDS = EAction["CHOOSE_DIAMONDS"]

PLAY_CARD_ACTIONS = [PLAY_CARD_1, PLAY_CARD_2, PLAY_CARD_3, PLAY_CARD_4]


suit_choice_action_to_esuit_map = {
    EAction["CHOOSE_SPADES"]: ESuit["SPADES"],
    EAction["CHOOSE_CLUBS"]: ESuit["CLUBS"],
    EAction["CHOOSE_HEARTS"]: ESuit["HEARTS"],
    EAction["CHOOSE_DIAMONDS"]: ESuit["DIAMONDS"]
}
def suit_choice_action_to_esuit(suit_choice_action):
    return suit_choice_action_to_esuit_map[suit_choice_action]


class Round:
    def __init__(self, last_dealer=None):
        self.finished = False
        self.trick_wins = [0] * 2
        self.round_points = [0] * 2
        self.trick_number = 0

        self.deck = Deck()
        self.dealer = get_clockwise_player(last_dealer) if last_dealer else EPlayer(random.randint(0, 3))

        self.current_player = get_clockwise_player(self.dealer)

        self.hands = [list([ECard(npint) for npint in array]) for array in np.array_split(self.deck.draw_ecards(16), 4)]

        self.upcard = ECard(self.deck.draw_ecards(1)[0])
        self.estate = FIRST_BIDDING_STATE

        self.trump_esuit = None
        self.maker = None
        self.going_alone = False

        self.played_ecards = []

    def get_actions(self) -> set[IntEnum]:
        if self.finished:
            return set()
        elif self.estate == FIRST_BIDDING_STATE:
            return {ORDER_UP, PASS}
        elif self.estate == DECIDING_GOING_ALONE_STATE:
            return {GO_ALONE, DONT_GO_ALONE}
        elif self.estate == SECOND_BIDDING_STATE:
            return {ORDER_UP, PASS}
        elif self.estate == CHOOSING_ESUIT_STATE:
            return {CHOOSE_SPADES, CHOOSE_CLUBS, CHOOSE_HEARTS, CHOOSE_DIAMONDS}
        elif self.estate == DEALER_DISCARD_STATE:
            return set(PLAY_CARD_ACTIONS)
        elif self.estate == PLAYING_STATE:
            current_hand = self.hands[self.current_player]

            # If no cards have been played, any remaining card can be played
            if len(self.played_ecards) == 0:
                actions = set()
                for i, ecard in enumerate(current_hand):
                    if ecard is not None:
                        actions.add(PLAY_CARD_ACTIONS[i])
                return actions

            # Determine which cards can be played according to the trump suit and led suit
            led_suit = get_ecard_esuit(self.played_ecards[0])

            is_valid = [False] * 4
            for i in range(4):
                ecard = current_hand[i]
                if ecard is None:
                    continue

                if get_ecard_esuit(ecard) == led_suit or get_ecard_esuit(ecard) == self.trump_esuit or (get_ecard_erank(ecard) == JACK and get_ecard_esuit(ecard) == get_same_color_esuit(self.trump_esuit)):
                    is_valid[i] = True

            # Allow the player to play valid cards (otherwise any remaining card if the player has no valid cards)
            if any(is_valid):
                actions = set()
                for i in range(4):
                    if is_valid[i]:
                        actions.add(PLAY_CARD_ACTIONS[i])
                return actions
            else:
                actions = set()
                for i, ecard in enumerate(current_hand):
                    if ecard is not None:
                        actions.add(PLAY_CARD_ACTIONS[i])
                return actions

    def take_action(self, action: IntEnum):
        assert action in self.get_actions(), f"The action {action} is not a legal move!"
        assert not self.finished, "No actions can be taken after the trick is finished!"

        if self.estate == FIRST_BIDDING_STATE:
            if action == ORDER_UP:
                self.trump_esuit = get_ecard_esuit(self.upcard)

                self.maker = self.current_player

                self.current_player = self.dealer
                self.estate = DEALER_DISCARD_STATE

            if action == PASS:
                if self.current_player == self.dealer:
                    self.estate = SECOND_BIDDING_STATE

                self.current_player = get_clockwise_player(self.current_player)

        elif self.estate == DEALER_DISCARD_STATE:
            replace_index = PLAY_CARD_ACTIONS.index(action)
            self.hands[self.current_player][replace_index] = self.upcard

            self.current_player = self.maker
            self.estate = DECIDING_GOING_ALONE_STATE

        elif self.estate == SECOND_BIDDING_STATE:
            if action == ORDER_UP:
                self.maker = self.current_player
                self.estate = CHOOSING_ESUIT_STATE

            if action == PASS:
                if self.current_player == self.dealer:
                    # If everyone passes for both rounds, reshuffle and do a new trick
                    self.finished = True

                self.current_player = get_clockwise_player(self.current_player)

        elif self.estate == CHOOSING_ESUIT_STATE:
            self.trump_esuit = suit_choice_action_to_esuit(action)

            self.estate = DECIDING_GOING_ALONE_STATE

        elif self.estate == DECIDING_GOING_ALONE_STATE:
            self.going_alone = action == GO_ALONE

            self.maker = self.current_player
            self.current_player = get_clockwise_player(self.dealer)
            self.estate = PLAYING_STATE

        elif self.estate == PLAYING_STATE:
            card_index = PLAY_CARD_ACTIONS.index(action)
            ecard = self.hands[self.current_player][card_index]
            self.hands[self.current_player][card_index] = None
            self.played_ecards.append(ecard)

            if len(self.played_ecards) == 4:
                self.end_trick()

                if self.trick_number == 4:
                    self.score_round()
                    self.finished = True
            else:
                self.current_player = get_clockwise_player(self.current_player)

    def get_current_player(self) -> IntEnum:
        return self.current_player

    def end_trick(self):
        # Determine the winner of the trick
        led_esuit = get_ecard_esuit(self.played_ecards[0])
        card_scores = [get_ecard_score(ecard, self.trump_esuit, led_esuit) for ecard in self.played_ecards]
        player_scores = [card_scores[(i + self.dealer + 3) % 4] for i in range(4)]  # TODO: make sure this is correct

        if self.going_alone:
            # Ignore the scores of teammates of players going alone
            player_scores[get_teammate(self.maker)] = 0

        highest_card_score = max(player_scores)
        winning_player = EPlayer(player_scores.index(highest_card_score))

        winning_team_index = eplayer_to_team_index(winning_player)

        self.trick_wins[winning_team_index] += 1

        # Set up the next trick
        self.trick_number += 1
        self.played_ecards = []
        self.current_player = winning_player

    def score_round(self):
        maker_team_index = eplayer_to_team_index(self.maker)
        defender_team_index = get_other_team_index(maker_team_index)

        if self.trick_wins[maker_team_index] == 5:
            self.round_points[maker_team_index] = 2

            # If the maker goes alone and wins all 5 tricks they get 4 points
            if self.going_alone:
                self.round_points[maker_team_index] = 4

        elif self.trick_wins[maker_team_index] >= 3:
            self.round_points[maker_team_index] = 1

        # The defenders "Eurchre" the makers if they win 3 or more
        if self.trick_wins[defender_team_index] >= 3:
            self.round_points[defender_team_index] = 2


class Euchre:
    def __init__(self):
        self.round = Round()
        self.team_points = [0] * 2

        self.finished = False
        self.winner = None

    def get_actions(self) -> set[IntEnum]:
        return self.round.get_actions()

    def take_action(self, action: IntEnum):
        self.round.take_action(action)

        if self.round.finished:
            for i in range(2):
                self.team_points[i] += self.round.round_points[i]

            # First to ten points wins
            most_points = max(self.team_points)
            if most_points >= 10:
                self.finished = True
                self.winner = self.team_points.index(most_points)  # Only one team can get points per round

            self.round = Round(last_dealer=self.round.dealer)

    def get_current_player(self):
        return self.round.get_current_player()

def text_interface(game):
    if game.finished:
        print("The game is finised!")
        return

    round = game.round
    current_player = round.current_player
    dealer = round.dealer
    hand = round.hands[current_player]
    hand_text = ", ".join([ecard.name if ecard is not None else "---" for ecard in hand])

    actions_text = "\n> Your options are:"
    for action in sorted(list(game.get_actions())):
        actions_text += f"\n\t> {action.value}: {action.name}"

    print(f"\n--- CURRENT PLAYER: \"{current_player.name}\" ({round.estate.name}) ---\n")

    if round.estate == FIRST_BIDDING_STATE:
        print("> It's the first round of bidding!")
        print(f"\t> Upcard: {round.upcard.name}")
        print(f"\t> Your hand: {hand_text}")
        print(f"\t> Dealer: Player {round.dealer}")

    elif round.estate == DEALER_DISCARD_STATE:
        print("> Someone ordered up, so you (as the dealer) can discard and get the upcard!")
        print(f"\t> Upcard: {round.upcard.name}")
        print(f"\t> Your hand: {hand_text}")

    elif round.estate == SECOND_BIDDING_STATE:
        print("> It's the second round of bidding! Order up to pick any suit!")
        print(f"\t> Upcard: {round.upcard.name}")
        print(f"\t> Your hand: {hand_text}")
        print(f"\t> Dealer: Player {round.dealer}")

    elif round.estate == CHOOSING_ESUIT_STATE:
        print("> You ordered up during the second bidding round! Pick any suit to be the trump!")
        print(f"\t> Your hand: {hand_text}")

    elif round.estate == DECIDING_GOING_ALONE_STATE:
        print("> You ordered up! Decide whether to go alone!")
        print(f"\t> Your hand: {hand_text}")

    elif round.estate == PLAYING_STATE:
        played_cards_text = ", ".join([ecard.name for ecard in round.played_ecards])
        print(f"\t> Played cards: {played_cards_text}")
        print(f"\t> Your hand: {hand_text}")

    print(actions_text)


# Play a game with random legal moves
# (Players 0 and 2 are on team 0 and players 1 and 3 are on team 1)
game = Euchre()

while not game.finished:
    text_interface(game)

    actions = game.get_actions()
    choice = random.choice(list(actions))

    print(f"\n> Playing action {choice}!")

    old_state = game.round.estate
    old_team_points = game.team_points.copy()

    game.take_action(choice)

    if old_state != game.round.estate and old_state == PLAYING_STATE:
        print(f"\n> Round finished! Team 0 got {game.team_points[0] - old_team_points[0]} points and team 1 got {game.team_points[1] - old_team_points[1]} points!")

print(f"\n\nThe winning team is team {game.winner}! The scores were team 0 with {game.team_points[0]} points and team 1 with {game.team_points[1]} points!")

# TODO:

# Should we be learning the full game of Euchre or just how to get the highest expected points in a round
#   - Works well until the end of the game (e.g. agent's team has 9 points) where a 1, 2, or 4 are all equal (all result in a win)
#   - Update: Let's do maximizing expected points per round

# RL: Add a function to convert a `game` to a unique state
#       - Decide how best to represent the game (e.g. order of cards in each hand doesn't matter)
# RL: (Potentially) design intermediate reward functions

# POMDP: (Potentially) add a function to load a game/round state?